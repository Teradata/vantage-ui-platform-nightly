{"version":3,"sources":["ng://@td-vantage/ui-platform/testing/cypress/utility/utility.ts","ng://@td-vantage/ui-platform/testing/cypress/mock/mockutility.ts"],"names":["BASE_URL","Cypress","config","LOGIN_URL","env","login","_a","username","password","cy","request","url","then","response","loginPageHtml","document","createElement","innerHTML","body","loginForm","querySelector","form","method","action","followRedirect","_redirectToHome","logout","visit","should","SSO_COOKIES","waitForAngular","get","window","win","Promise","resolve","reject","testabilities","Error","count","length","forEach","testability","whenStable","unit","e2e","allowedHeaders","MockUtility","this","mocking","recording","prototype","setUp","testName","testType","templates","userName","record","_this","now","server","timestamp","moment","format","urlMethodFixtureMap","Map","recordedURLMethodFixtureMap","route","onResponse","xhr","recordResponse","TestType","registerRoute","template","Commands","add","routeDef","status","fixture","credentials","dir","mockDataFile","exec","results","stdout","byURLRoutesMap","Object","keys","byMethodRoutesMap","fixtureRouteDefs","urlMethodKey","firstRouteDef","fixtureRouteDef","undefined","set","push","registerMockRoute","as","alias","headers","responseKey","URL","pathname","shift","updatedFixtureRouteDef","JSON","stringify","substring","key","indexOf","byMethodMap","tearDown","Cookies","defaults","whitelist"],"mappings":"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","sourcesContent":["/// <reference types=\"cypress\" />\n\nconst BASE_URL: string = Cypress.config('baseUrl'); // ex: http://localhost:4200\nconst LOGIN_URL: string = Cypress.env('loginUrl'); // ex: https://vantage.url.io/auth\n\nexport interface ILoginCredentials {\n  username: string;\n  password: string;\n}\n\n// inspired by https://vrockai.github.io/blog/2017/10/28/cypress-keycloak-intregration/\nexport function login({ username, password }: ILoginCredentials): void {\n  cy.request({\n    url: LOGIN_URL,\n  }).then((response: any) => {\n    const loginPageHtml: HTMLElement = document.createElement('html');\n    loginPageHtml.innerHTML = response.body;\n    const loginForm: HTMLFormElement = loginPageHtml.querySelector('#kc-form-login');\n    if (loginForm) {\n      cy.request({\n        form: true,\n        method: 'POST',\n        url: loginForm.action,\n        followRedirect: false,\n        body: {\n          username,\n          password,\n        },\n      }).then(() => {\n        _redirectToHome();\n      });\n    } else {\n      _redirectToHome();\n    }\n  });\n}\n\nexport function logout(): void {\n  cy.request('/api/user/logout');\n}\n\nfunction _redirectToHome(): void {\n  cy.visit(BASE_URL);\n  cy.url().should('not.include', LOGIN_URL);\n  cy.url().should('include', BASE_URL);\n}\n\nexport const SSO_COOKIES: string[] = ['USER_SSO_ID', 'XSRF-TOKEN'];\nexport function whiteListSSOCookies(): void {\n  Cypress.Cookies.defaults({ whitelist: SSO_COOKIES });\n}\n\nexport function waitForAngular(): Cypress.Chainable {\n  cy.get('[ng-version]').should('exist');\n  return cy.window().then((win: Window) => {\n    return new Cypress.Promise(\n      (resolve: (thenableOrResult?: {} | PromiseLike<{}>) => void, reject: (error?: any) => void) => {\n        const testabilities: any = win['getAllAngularTestabilities']();\n        if (!testabilities) {\n          return reject(new Error('No testabilities. Is Angular loaded?'));\n        }\n        let count: number = testabilities.length;\n        testabilities.forEach((testability: any) =>\n          testability.whenStable(() => {\n            count--;\n            if (count !== 0) {\n              return;\n            }\n            resolve();\n          }),\n        );\n      },\n    );\n  });\n}\n","/// <reference types=\"cypress\" />\n\ndeclare global {\n  // tslint:disable-next-line\n  namespace Cypress {\n    // tslint:disable-next-line\n    interface Chainable {\n      now(func: string, ...args: any[]): Chainable<Element>;\n    }\n  }\n}\n\nimport { login, logout, ILoginCredentials, waitForAngular } from '../utility/utility';\n\nimport moment from 'moment';\n\nexport enum TestType {\n  'unit' = 'unit',\n  'e2e' = 'e2e',\n}\n\nenum Methods {\n  'GET' = 'GET',\n  'PUT' = 'PUT',\n  'POST' = 'POST',\n  'PATCH' = 'PATCH',\n  'DELETE' = 'DELETE',\n}\n\ninterface IRouteDef {\n  url: string;\n  method: string;\n  status?: number;\n  headers?: any;\n  response?: any;\n  onResponse?: any;\n}\n\ninterface IFixtureRouteDef {\n  alias?: string;\n  status?: number;\n  headers?: any;\n  response?: any;\n  onResponse?: any;\n}\n\nconst allowedHeaders: string[] = ['content-type', 'x-length', 'x-page', 'x-total', 'x-total-pages'];\n\nconst PIPE: string = '|';\nconst SLASH: string = '/';\n\nexport class MockUtility {\n  timestamp: string;\n  recordedURLMethodFixtureMap: Map<string, Map<string, IFixtureRouteDef[]>>;\n  urlMethodFixtureMap: Map<string, IFixtureRouteDef[]>;\n  mocking: boolean = false;\n  recording: boolean = false;\n  testType: TestType;\n  testName: string;\n\n  /**\n   * Method that handles all boilerplate work to set up test.\n   *\n   * @param testName testname used to determine existence of test specific fixtures and\n   * @param testType unit or e2e\n   * @param templates array of templates to be loaded (eg. 'empty' or 'golden')\n   * @param userName user name matching fixture containing credentials\n   * @param record force recording for this test, default is false\n   */\n  setUp(testName: string, testType: TestType, templates: string[], userName: string, record: boolean = false): void {\n    cy.now('log', 'Test: ' + testName + SLASH + testType);\n    this.testName = testName;\n    this.testType = testType;\n\n    // Start server to support routes\n    cy.server();\n\n    // Create timestamp and structures to retain fixture data\n    this.timestamp = moment().format('LTS');\n    this.urlMethodFixtureMap = new Map<string, IFixtureRouteDef[]>();\n    this.recordedURLMethodFixtureMap = new Map<string, Map<string, IFixtureRouteDef[]>>();\n\n    // Conditionally turn on recording\n    if (Cypress.env('record') || record) {\n      this.recording = true;\n\n      cy.now('log', 'Recording...');\n      cy.route({\n        url: '/api/**',\n        onResponse: (xhr: any) => this.recordResponse(xhr),\n      });\n    }\n\n    // Conditionally turn on mocking\n    if (Cypress.env('mock') || testType === TestType.unit) {\n      cy.now('log', 'Mocking...');\n      this.mocking = true;\n    }\n\n    // Add routes for user logon\n    if (this.mocking && !this.recording) {\n      this.registerRoute(userName);\n    }\n    // Load template and test specific routes\n    templates.forEach((template: string) => {\n      this.registerRoute('templates/' + template);\n      this.registerRoute('templates/' + template + SLASH + userName);\n    });\n    this.registerRoute('testspecific/' + testName);\n\n    // Add new route command that alters its behavior based on mode.\n    // If recording or production, just wait.\n    // If mocking, allow returning mock results.\n    Cypress.Commands.add('route2', (routeDef: IRouteDef) => {\n      if (Cypress.env('mock')) {\n        cy.now('log', 'Setting route to mock');\n        cy.route(routeDef);\n      } else {\n        cy.now('log', ' Setting route to alias');\n        cy.route(routeDef.url);\n      }\n    });\n\n    cy.route({\n      method: 'GET',\n      url: '/api/user/logout',\n      status: 200,\n      response: {},\n    });\n\n    // Handle login based on mode.\n    // Mock, bypass login\n    // Otherwise, log in using credentials from fixture.\n    if (this.mocking && !this.recording) {\n      cy.visit('/');\n    } else {\n      cy.fixture('credentials/' + userName).then((credentials: ILoginCredentials) => {\n        login(credentials);\n      });\n    }\n\n    // Wait for page to load\n    waitForAngular();\n  }\n\n  /**\n   * Discover any mock data fixtures under the specified directory hierarchy\n   * and register associated cy.routes.\n   *\n   * @param filename fixture filename\n   */\n  registerRoute(dir: string): void {\n    // Check to see if the file exists.\n    const mockDataFile: string = dir + '/mockdata.json';\n    cy.exec('if [ -f cypress/fixtures/' + mockDataFile + ' ]; then ls cypress/fixtures/' + mockDataFile + '; fi').then(\n      (results: any) => {\n        if (!results.stdout) {\n          return;\n        }\n        cy.fixture(mockDataFile).then((byURLRoutesMap: Map<string, Map<string, IFixtureRouteDef[]>>) => {\n          // Iterate through file processing URL/method mappings\n          // File is a map with URL as the key. Values are maps\n          // in turn, where each map has method as the key value.\n          // The value of these internal maps is an array of responses.\n          Object.keys(byURLRoutesMap).forEach((url: string) => {\n            const byMethodRoutesMap: Map<string, IFixtureRouteDef[]> = byURLRoutesMap[url];\n            Object.keys(byMethodRoutesMap).forEach((method: string) => {\n              const fixtureRouteDefs: IFixtureRouteDef[] = byMethodRoutesMap[method];\n              const urlMethodKey: string = url + PIPE + method;\n              let firstRouteDef: boolean = false;\n              fixtureRouteDefs.forEach((fixtureRouteDef: IFixtureRouteDef) => {\n                // Known mocks supercede recording\n                if (this.mocking) {\n                  if (this.urlMethodFixtureMap.get(urlMethodKey) === undefined) {\n                    this.urlMethodFixtureMap.set(urlMethodKey, []);\n                    firstRouteDef = true;\n                  }\n                  this.urlMethodFixtureMap.get(urlMethodKey).push(fixtureRouteDef);\n\n                  if (firstRouteDef) {\n                    this.registerMockRoute(url, method, fixtureRouteDef);\n                  }\n                } else if (this.recording) {\n                  // onResponse records XHR response\n                  const routeDef: IRouteDef = {\n                    method,\n                    url,\n                    onResponse: (xhr: any) => {\n                      this.recordResponse(xhr);\n                    },\n                  };\n\n                  cy.now('log', 'Registering recording route:');\n                  cy.now('log', 'url/method: ' + url + SLASH + method);\n                  cy.route(routeDef).as(fixtureRouteDef.alias);\n                } else {\n                  const routeDef: IRouteDef = {\n                    method,\n                    url,\n                  };\n\n                  cy.now('log', 'Registering alias route:');\n                  cy.now('log', 'url/method: ' + url + SLASH + method);\n                  cy.now('log', 'alias: ' + fixtureRouteDef.alias);\n                  cy.route(routeDef).as(fixtureRouteDef.alias);\n                }\n              });\n            });\n          });\n        });\n      },\n    );\n  }\n\n  registerMockRoute(url: string, method: string, fixtureRouteDef: IFixtureRouteDef): void {\n    const routeDef: IRouteDef = {\n      url,\n      method,\n      status: fixtureRouteDef.status,\n      headers: fixtureRouteDef.headers,\n      response: fixtureRouteDef.response,\n      onResponse: (xhr: any) => {\n        const responseURL: URL = new URL(xhr.url);\n        const responseKey: string = responseURL.pathname + PIPE + xhr.method;\n        const fixtureRouteDefs: IFixtureRouteDef[] = this.urlMethodFixtureMap.get(responseKey);\n        // If more routes exist, shift old fixture, and re-assign\n        if (fixtureRouteDefs.length > 1) {\n          fixtureRouteDefs.shift();\n          const updatedFixtureRouteDef: IFixtureRouteDef = fixtureRouteDefs[0];\n          this.registerMockRoute(url, method, updatedFixtureRouteDef);\n        }\n      },\n    };\n\n    cy.now('log', 'Registering mock route:');\n    cy.now('log', 'url/method: ' + url + SLASH + method);\n    cy.now('log', 'alias: ' + fixtureRouteDef.alias);\n    cy.now('log', 'status: ' + fixtureRouteDef.status);\n    cy.now('log', 'headers: ' + JSON.stringify(fixtureRouteDef.headers));\n    cy.now('log', 'response: ' + JSON.stringify(fixtureRouteDef.response));\n    cy.route(routeDef).as(fixtureRouteDef.alias);\n  }\n\n  recordResponse(xhr: any): void {\n    // Manipulate URL value to strip host info\n    const url: string = xhr.url.substring(Cypress.config('baseUrl').length);\n    const method: string = xhr.method;\n\n    // Remove black listed headers\n    const headers: any = {};\n    Object.keys(xhr.response.headers).forEach((key: string) => {\n      if (allowedHeaders.indexOf(key) !== -1) {\n        headers[key] = xhr.response.headers[key];\n      }\n    });\n\n    const fixtureRouteDef: IFixtureRouteDef = {\n      alias: url + PIPE + method,\n      status: xhr.status,\n      headers,\n      response: xhr.response.body,\n    };\n\n    if (!this.recordedURLMethodFixtureMap[url]) {\n      this.recordedURLMethodFixtureMap[url] = {};\n    }\n    const byMethodMap: Map<string, IFixtureRouteDef[]> = this.recordedURLMethodFixtureMap[url];\n    if (!byMethodMap[method]) {\n      byMethodMap[method] = [];\n    }\n    cy.now('log', 'Recording response:');\n    cy.now('log', 'url/method: ' + url + SLASH + method);\n    cy.now('log', 'response: ' + JSON.stringify(fixtureRouteDef));\n    byMethodMap[method].push(fixtureRouteDef);\n  }\n\n  tearDown(): void {\n    if (this.recording) {\n      cy.now(\n        'log',\n        'Writing record fixture: ' + 'cypress/recordings/' + this.testName + SLASH + this.timestamp + '/mockdata.json',\n      );\n      cy.now(\n        'writeFile',\n        'cypress/recordings/' + this.testName + SLASH + this.timestamp + '/mockdata.json',\n        this.recordedURLMethodFixtureMap,\n      );\n    }\n    if (!this.mocking) {\n      logout();\n    }\n  }\n}\n"]}